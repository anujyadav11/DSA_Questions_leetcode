/***************************************************** JAVA ************************************************/

Optimal solution -  We perform binary search on the rotated sorted array by identifying the sorted half at each step and deciding whether the target lies within 
                    that range to safely discard the other half.

class Solution {
    // Function to search for an element in a rotated sorted array
    public int search(int[] nums, int target) {
        //Initialise pointers for binary search
        int low = 0;
        int high = nums.length - 1;
        // Perform binary search
        while (low <= high) {
            // Calculate the middle index
            int mid = (low + high) / 2;
            // Check if the middle element is the target
            if (nums[mid] == target) {
                return mid;
            }
            // Check if the left half (low to mid) is sorted
            if (nums[low] <= nums[mid]) {
                // Check if the target is within the range of the left half
                if (target >= nums[low] && target <= nums[mid]) {
                    high = mid - 1; // Adjust the search range to the left half
                } else {
                    low = mid + 1; // Adjust the search range to the right half
                }
            }
            // If the left half is not sorted, then the right half must be sorted
            else {
                // Check if the target is within the range of the right half
                if (target >= nums[mid] && target <= nums[high]) {
                    low = mid + 1; // Adjust the search range to the right half
                } else {
                    high = mid - 1; // Adjust the search range to the left half
                }
            }
        }
        // If the loop exits and the target is not found, return -1
        return -1;
    }
}
Time Complexity :- O(log n).
Space Complexity :- O(1).
