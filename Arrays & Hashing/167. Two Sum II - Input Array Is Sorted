/**************************************** JAVA ******************************************/

Optimal Solution - we are using the two-pointer technique to get the index of two numbers that sum to the target given.

class Solution {
    public int[] twoSum(int[] numbers, int target) {
        // Length of the input array
        int n = numbers.length;
        // Pointer i starts from the beginning of the array
        int i = 0;
        // Pointer j starts from the end of the array
        int j = n - 1;
        // Continue searching while the two pointers do not cross
        while (i < j) {
            // Calculate the sum of values at pointers i and j
            int num = numbers[i] + numbers[j];
            // If the current sum is smaller than the target,
            // move the left pointer to the right to increase the sum
            if (num < target) {
                i++;
            }
            // If the current sum is greater than the target,
            // move the right pointer to the left to decrease the sum
            else if (num > target) {
                j--;
            }
            // If the current sum equals the target,
            // return the 1-based indices as required by the problem
            else {
                return new int[] { i + 1, j + 1 };
            }
        }
        // If no valid pair is found (though the problem guarantees one),
        // return an empty array
        return new int[] {};
    }
}
Time Complexity :- O(N).
Space Complexity :- O(1).
