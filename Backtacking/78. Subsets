/*********************************************** JAVA **************************************************/

Optimal Solution - Generate all subsets using backtracking by exploring inclusion and exclusion of each element.

class Solution {
    // Generates all possible subsets (power set) of the given array
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> resList = new ArrayList<>();
        // Start backtracking from index 0 with an empty subset
        backtrack(resList, new ArrayList<>(), nums, 0);
        return resList;
    }
    /*
     * backtrack builds subsets by choosing or skipping each element
     *
     * resList  -> stores all subsets
     * tempSet  -> current subset being built
     * nums     -> input array
     * start    -> index from where to explore choices
     */
    public void backtrack(List<List<Integer>> resList,
                          List<Integer> tempSet,
                          int[] nums,
                          int start) {
        // Add a copy of the current subset
        resList.add(new ArrayList<>(tempSet));
        // Explore further elements
        for (int i = start; i < nums.length; i++) {
            // Choose the current element
            tempSet.add(nums[i]);
            // Recurse with next index
            backtrack(resList, tempSet, nums, i + 1);
            // Backtrack (remove last chosen element)
            tempSet.remove(tempSet.size() - 1);
        }
    }
}

Time Complexity :- O(2ⁿ × N).
Space Complexity :- O(N).
