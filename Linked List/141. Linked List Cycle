/************************************************** JAVA ******************************************************/

Optimal solution - We use two pointers moving at different speeds, and if a cycle exists, the fast pointer will eventually meet the slow pointer.


class Solution {
    public boolean hasCycle(ListNode head) {
        // Slow and fast pointers both start at head
        ListNode slow = head;
        ListNode fast = head;
        // Traverse the list while fast pointer can move ahead
        while (fast != null && fast.next != null) {
            // Slow moves one step
            slow = slow.next;
            // Fast moves two steps
            fast = fast.next.next;
            // If both pointers meet, a cycle exists
            if (slow == fast) {
                return true;
            }
        }
        // If fast reaches null, no cycle exists
        return false;
    }
}

Time Complexity :- O(N).
Space Complexity :- O(1).
